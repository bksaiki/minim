(import (prefix #%c-kernel $))

;; --------------------------------------------------------
;; Low-level exceptions

(export error
        raise-argument-error)

(define (error who msg . args)
  ($error who msg args))

(define (raise-argument-error who expect v)
  (error who "contract violation" expect v))

;; --------------------------------------------------------
;; Contract-less primitives

;; type predicates

(export null?
        true?
        false?
        void?
        eof?
        symbol?
        fixnum?
        char?
        string?
        pair?
        procedure?
        list?
        boolean?)

(define null? $null?)
(define true? $true?)
(define false? $false?)
(define void? $void?)
(define eof? $eof?)
(define symbol? $symbol?)
(define fixnum? $fixnum?)
(define char? $char?)
(define string? $string?)
(define pair? $pair?)
(define procedure? $procedure?)
(define list? $list?)

(define (boolean? x)
  (or (true? x) (false? x)))

;; equality

(export eq? equal?)

(define eq? $eq?)
(define equal? $equal?)

;; constructors

(export not
        cons
        list)

(define not $not)
(define cons $cons)
(define list $list)

;; special

(export apply
        call/cc
        call-with-current-continuation
        call-with-values
        dynamic-wind
        values
        void)

(define apply $apply)
(define call/cc $call/cc)
(define call-with-current-continuation call/cc)
(define call-with-values $call-with-values)
(define dynamic-wind $dynamic-wind)
(define values $values)
(define void $void)

;; --------------------------------------------------------
;; Pair accessors

(export car
        cdr
        caar
        cadr
        cdar
        cddr
        caaar
        caadr
        cadar
        caddr
        cdaar
        cdadr
        cddar
        cdddr
        caaaar
        caaadr
        caadar
        caaddr
        cadaar
        cadadr
        caddar
        cadddr
        cdaaar
        cdaadr
        cdadar
        cdaddr
        cddaar
        cddadr
        cdddar
        cddddr)

(define (car x)
  (unless (pair? x)
    (raise-argument-error 'car "pair?" x))
  ($car x))

(define (cdr x)
  (unless (pair? x)
    (raise-argument-error 'cdr "pair?" x))
  ($cdr x))

(define ((make-pair-argument-error who why) what)
  (raise-argument-error who why what))

(define caar
  (let ([oops! (make-pair-argument-error 'caar "(pairof pair? any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                ($car t)
                (oops! x)))
          (oops! x)))))

(define cadr
  (let ([oops! (make-pair-argument-error 'cadr "(pairof any pair?)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                ($car t)
                (oops! x)))
          (oops! x)))))

(define cdar
  (let ([oops! (make-pair-argument-error 'cdar "(pairof pair? any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                ($cdr t)
                (oops! x)))
          (oops! x)))))

(define cddr
  (let ([oops! (make-pair-argument-error 'cddr "(pairof any pair?)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                ($cdr t)
                (oops! x)))
          (oops! x)))))

(define caaar
  (let ([oops! (make-pair-argument-error 'caaar "(pairof (pairof pair? any) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define caadr
  (let ([oops! (make-pair-argument-error 'caadr "(pairof any (pairof pair? any))")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cadar
  (let ([oops! (make-pair-argument-error 'cadar "(pairof (pairof any pair?) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define caddr
  (let ([oops! (make-pair-argument-error 'caddr "(pairof (pairof any pair?) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      ($car t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdaar
  (let ([oops! (make-pair-argument-error 'cdaar "(pairof (pairof pair? any) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdadr
  (let ([oops! (make-pair-argument-error 'cdadr "(pairof any (pairof pair? any))")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cddar
  (let ([oops! (make-pair-argument-error 'cddar "(pairof (pairof any pair?) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdddr
  (let ([oops! (make-pair-argument-error 'cdddr "(pairof (pairof any pair?) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      ($cdr t)
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define caaaar
  (let ([oops! (make-pair-argument-error 'caaaar "(pairof (pairof (pairof pair? any) any) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define caaadr
  (let ([oops! (make-pair-argument-error 'caaadr "(pairof any (pairof (pairof pair? any) any))")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define caadar
  (let ([oops! (make-pair-argument-error 'caadar "(pairof (pairof any (pairof pair? any)) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define caaddr
  (let ([oops! (make-pair-argument-error 'caaddr "(pairof (pairof any (pairof pair? any)) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cadaar
  (let ([oops! (make-pair-argument-error 'cadaar "(pairof (pairof (pairof any pair?) any) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cadadr
  (let ([oops! (make-pair-argument-error 'cadadr "(pairof any (pairof (pairof any pair?) any))")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define caddar
  (let ([oops! (make-pair-argument-error 'caddar "(pairof (pairof any (pairof any pair?)) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cadddr
  (let ([oops! (make-pair-argument-error 'cadddr "(pairof (pairof any (pairof any pair?) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($car t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdaaar
  (let ([oops! (make-pair-argument-error 'cdaaar "(pairof (pairof (pairof pair? any) any) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdaadr
  (let ([oops! (make-pair-argument-error 'cdaadr "(pairof any (pairof (pairof pair? any) any))")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdadar
  (let ([oops! (make-pair-argument-error 'cdadar "(pairof (pairof any (pairof pair? any)) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdaddr
  (let ([oops! (make-pair-argument-error 'cdaddr "(pairof (pairof any (pairof pair? any)) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($car t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cddaar
  (let ([oops! (make-pair-argument-error 'cddaar "(pairof (pairof (pairof any pair?) any) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cddadr
  (let ([oops! (make-pair-argument-error 'cddadr "(pairof any (pairof (pairof any pair?) any))")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($car t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cdddar
  (let ([oops! (make-pair-argument-error 'cdddar "(pairof (pairof any (pairof any pair?)) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($car x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

(define cddddr
  (let ([oops! (make-pair-argument-error 'cddddr "(pairof (pairof any (pairof any pair?) any)")])
    (lambda (x)
      (if (pair? x)
          (let ([t ($cdr x)])
            (if (pair? t)
                (let ([t ($cdr t)])
                  (if (pair? t)
                      (let ([t ($cdr t)])
                        (if (pair? t)
                            ($cdr t)
                            (oops! x)))
                      (oops! x)))
                (oops! x)))
          (oops! x)))))

;; --------------------------------------------------------
;; Pair setters

(export set-car!
        set-cdr!)

(define (set-car! p x)
  (if (pair? p)
      ($set-car! p x)
      (raise-argument-error 'set-car! "pair?" p)))

(define (set-cdr! p x)
  (if (pair? p)
      ($set-cdr! p x)
      (raise-argument-error 'set-cdr! "pair?" p)))

;; --------------------------------------------------------
;; Numbers

(export integer?
        rational?
        real?
        complex?
        number?
        = > < >= <=
        negative-integer?
        positive-integer?
        non-negative-integer?
        negative?
        positive?
        non-negative?
        zero?)

(define integer? fixnum?)
(define rational? integer?)
(define real? rational?)
(define complex? real?)

(define number? complex?)

(define (non-number-error name x)
  (raise-argument-error name "number?" x))

; (define (+ . xs)
;   (cond
;     [(null? xs) 0]
;     [(null? (cdr xs))
;      (unless (number? (car xs))
;        (non-number-error '+ (car xs)))
;      (car xs)]
;     [(null? (cddr xs))
;      (unless (number? (car xs))
;        (non-number-error '+ (car xs)))
;      (unless (number? (cadr xs))
;        (non-number-error '+ (cadr xs)))
;      ($fx+ (car xs) (cadr xs))]
;     [else
;      (unless (number? (car xs))
;        (non-number-error '+ (car xs)))
;      (let loop ([x (car xs)] [y (cadr xs)] [xs (cddr xs)])
;        (
;        (unless (number? (cadr xs))
;        (non-number-error '+ (cadr xs)))
     

(define (make-comparator who cmp)
  (lambda (x . xs)
    (cond
      [(null? xs)
       (unless (number? x)
         (non-number-error who x))
       #t]
      [(null? (cdr xs))
       (unless (number? x)
         (non-number-error who x))
       (unless (number? (car xs))
         (non-number-error who (car xs)))
       (cmp x (car xs))]
      [else 
       (unless (number? x)
         (non-number-error who x))
       (loop ([x x] [y (car xs)] [xs (cdr xs)])
         (cond
           [(null? xs) (cmp x y)]
           [(number? y) (and (cmp x y) (loop y (car xs) (cdr xs)))]
           [else (non-number-error who y)]))])))

(define = (make-comparator '= $fx=))
(define > (make-comparator '> $fx>))
(define < (make-comparator '< $fx<))
(define >= (make-comparator '>= $fx>=))
(define <= (make-comparator '>= $fx<=))

(define (negative-integer? x)
  (and (integer? x) (< x 0)))

(define (non-negative-integer? x)
  (and (integer? x) (>= x 0)))

(define (positive-integer? x)
  (and (integer? x) (>= x 0)))

(define (negative? x)
  (< x 0))

(define (non-negative? x)
  (>= x 0))

(define (positive? x)
  (>= x 0))

(define (zero? x)
  (= x 0))

;; --------------------------------------------------------
;; Lists

(export length
        reverse
        append
        for-each
        map
        andmap
        ormap)

(define (non-list-error name x)
  (raise-argument-error name "list?" x))

(define (length x)
  (unless (list? x)
    (non-list-error 'length x))
  ($length x))

(define (reverse x)
  (unless (list? x)
    (non-list-error 'reverse x))
  ($reverse x))

(define (append . xss)
  (cond
    [(null? xss) '()]
    [(null? (cdr xss))
     (unless (list? (car xss))
       (non-list-error 'append (car xss)))
     (car xss)]
    [(null? (cddr xss))
     (unless (list? (car xss))
       (non-list-error 'append (car xss)))
     (unless (list? (cadr xss))
       (non-list-error 'append (cadr xss)))
     ($append (car xss) (cadr xss))]
    [else
     (let loop ([acc '()] [xss (reverse xss)])
       (cond
         [(null? xss) acc]
         [(list? xss) (loop ($append (car xss) acc) (cdr xss))]
         [else (non-list-error 'append (car xss))]))]))

(define (for-each1 f xs)
  (cond
    [(null? xs) (void)]
    [(null? (cdr xs))
     (f (car xs))
     (void)]
    [else
     (let loop ([xs xs])
       (unless (null? xs)
         (f (car xs))
         (loop (cdr xs))))]))

(define (map1 f xs)
  (cond
    [(null? xs) '()]
    [(null? (cdr xs)) (list (f (car xs)))]
    [else
     (let loop ([xs xs] [ys '()])
       (if (null? xs)
           (reverse ys)
           (loop (cdr xs) (cons (f (car xs)) ys))))]))

(define (andmap1 f xs)
  (cond
    [(null? xs) #t]
    [(null? (cdr xs)) (if (f (car xs)) #t #f)]
    [else 
     (let loop ([xs xs])
       (cond
         [(null? xs) #t]
         [(f (car xs)) (loop (cdr xs))]
         [else #f]))]))

(define (ormap1 f xs)
  (cond
    [(null? xs) #f]
    [(null? (cdr xs)) (if (f (car xs)) #t #f)]
    [else 
     (let loop ([xs xs])
       (cond
         [(null? xs) #f]
         [(f (car xs)) #t]
         [else (loop (cdr xs))]))]))

(define (check-map-args! who f xss)
  (unless (procedure? f)
    (raise-argument-error who "procedure?" f))
  (let loop ([xss xss] [len #f])
    (unless (null? xss)
      (let ([xs (car xss)])
        (unless (list? xs)
          (raise-argument-error who "list?" xs))
        (let ([len* (length xs)])
          (unless (or (not len) (= len len*))
            (error who "list does have expected length" xs len))
          (loop (cdr xss) len*))))))

(define (for-each f xs . xss)
  (let ([xss (cons xs xss)])
    (check-map-args! 'for-each f xss)
    (if (null? (cdr xss))
        (for-each1 f xs)
        (let loop ([xss xss])
          (unless (null? (car xss))
            (apply f (map1 car xss))
            (loop (map1 cdr xss)))))))

(define (map f xs . xss)
  (let ([xss (cons xs xss)])
    (check-map-args! 'map f xss)
    (if (null? (cdr xss))
        (map1 f xs)
        (let loop ([xss xss] [ys '()])
          (if (null? (car xss))
              (reverse ys)
              (let ([y (apply f (map1 car xss))])
                (loop (map1 cdr xss) (cons y ys))))))))

(define (andmap f xs . xss)
  (let ([xss (cons xs xss)])
    (check-map-args! 'andmap f xss)
    (if (null? (cdr xss))
        (andmap1 f xs)
        (let loop ([xss xss])
          (cond
            [(null? (car xss)) #t]
            [(f (map1 car xss)) (loop (map1 cdr xss))]
            [else #f])))))

(define (ormap f xs . xss)
  (let ([xss (cons xs xss)])
    (check-map-args! 'ormap f xss)
    (if (null? (cdr xss))
        (ormap1 f xs)
        (let loop ([xss xss])
          (cond
            [(null? (car xss)) #f]
            [(f (map1 car xss)) #t]
            [else (loop (map1 cdr xss))])))))
